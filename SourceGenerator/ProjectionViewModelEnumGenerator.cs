using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator;

[Generator]
public class ProjectionViewModelEnumGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var projectionNames = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                transform: static (ctx, _) =>
                {
                    if (ctx.Node is not ClassDeclarationSyntax classSyntax)
                        return null;

                    if (ctx.SemanticModel.GetDeclaredSymbol(classSyntax) is not INamedTypeSymbol typeSymbol)
                        return null;

                    if (typeSymbol.Interfaces.Any(@interface => @interface.Name == "IProjection"))
                    {
                        return typeSymbol;
                    }

                    // Traverse base types to find SingleStreamProjection<T>
                    for (var baseType = typeSymbol.BaseType; baseType is not null; baseType = baseType.BaseType)
                    {
                        if (baseType is { ConstructedFrom.Name: "SingleStreamProjection" } singleStreamProjection)
                        {
                            return singleStreamProjection.TypeArguments[0] as INamedTypeSymbol;
                        }

                        if (baseType is { ConstructedFrom.Name: "MultiStreamProjection" } multiStreamProjection)
                        {
                            return multiStreamProjection.TypeArguments[0] as INamedTypeSymbol;
                        }
                    }

                    return null;
                })
            .Where(static t => t is not null)
            .Select(static (t, _) => t!)
            .Collect();
        context.RegisterSourceOutput(projectionNames, (ctx, symbols) =>
        {
            var codeBuilder = new StringBuilder();
            codeBuilder.AppendLine("""
                                   // <auto-generated />

                                   namespace Skeleton;

                                   public enum ProjectionViewModelEnum
                                   {
                                   """);
            foreach (var symbol in symbols)
            {
                codeBuilder.AppendLine($"    {symbol.Name},");
            }

            codeBuilder.AppendLine("}");
            codeBuilder.AppendLine("""

                                   public static class ProjectionViewModelEnumExtensions
                                   {
                                       public static string GetProjectionViewModelName(this ProjectionViewModelEnum value)
                                       {
                                           return value switch
                                           {
                                   """);
            foreach (var symbol in symbols.Where(symbol => symbol.AllInterfaces.Any(i => i.Name == "IProjection")))
            {
                codeBuilder.AppendLine($"            ProjectionViewModelEnum.{symbol.Name} => \"{symbol.ToDisplayString()}\",");
            }

            codeBuilder.AppendLine("""
                                               _ => value.ToString()
                                           };
                                       }
                                   }
                                   """);


            ctx.AddSource("ProjectionViewModelEnum.g.cs", codeBuilder.ToString());
        });
    }
}